(window.webpackJsonp=window.webpackJsonp||[]).push([[7],{206:function(a,t,e){"use strict";e.r(t);var s=e(0),r=Object(s.a)({},(function(){var a=this,t=a.$createElement,e=a._self._c||t;return e("ContentSlotsDistributor",{attrs:{"slot-key":a.$parent.slotKey}},[e("h1",{attrs:{id:"getting-started"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#getting-started","aria-hidden":"true"}},[a._v("#")]),a._v(" Getting Started")]),a._v(" "),e("p",[e("strong",[a._v("Caliban")]),a._v(" is a purely functional library for creating GraphQL backends in Scala.\nIt relies on "),e("a",{attrs:{href:"https://github.com/propensive/magnolia",target:"_blank",rel:"noopener noreferrer"}},[a._v("Magnolia"),e("OutboundLink")],1),a._v(" to automatically derives GraphQL schemas from your data types, "),e("a",{attrs:{href:"https://github.com/lihaoyi/fastparse",target:"_blank",rel:"noopener noreferrer"}},[a._v("Fastparse"),e("OutboundLink")],1),a._v(" to parse queries and "),e("a",{attrs:{href:"https://github.com/zio/zio",target:"_blank",rel:"noopener noreferrer"}},[a._v("ZIO"),e("OutboundLink")],1),a._v(" to handle various effects.")]),a._v(" "),e("p",[a._v("The design principles behind the library are the following:")]),a._v(" "),e("ul",[e("li",[a._v("pure interface: errors and effects are returned explicitly (no exceptions thrown), all returned types are referentially transparent (no "),e("code",[a._v("Future")]),a._v(").")]),a._v(" "),e("li",[a._v("clean separation between schema definition and implementation: schema is defined and validated at compile time using Scala standard types, resolver is a simple value provided at runtime.")]),a._v(" "),e("li",[a._v("minimal amount of boilerplate: no need to manually define a schema for every type in your API.")])]),a._v(" "),e("h2",{attrs:{id:"dependencies"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#dependencies","aria-hidden":"true"}},[a._v("#")]),a._v(" Dependencies")]),a._v(" "),e("p",[a._v("To use "),e("code",[a._v("caliban")]),a._v(", add the following line in your "),e("code",[a._v("build.sbt")]),a._v(" file:")]),a._v(" "),e("div",{staticClass:"language- extra-class"},[e("pre",{pre:!0,attrs:{class:"language-text"}},[e("code",[a._v('libraryDependencies += "com.github.ghostdogpr" %% "caliban" % "0.0.6"\n')])])]),e("p",[a._v("Note that caliban is also available for ScalaJS.")]),a._v(" "),e("h2",{attrs:{id:"a-simple-example"}},[e("a",{staticClass:"header-anchor",attrs:{href:"#a-simple-example","aria-hidden":"true"}},[a._v("#")]),a._v(" A simple example")]),a._v(" "),e("p",[a._v("Creating a GraphQL API with Caliban is as simple as creating a case class. Indeed, the whole GraphQL schema will be derived from a case class structure (its fields and the other types it references), and the resolver is just an instance of that case class.")]),a._v(" "),e("p",[a._v("Let's say we have a class "),e("code",[a._v("Character")]),a._v(" and 2 functions: "),e("code",[a._v("getCharacters")]),a._v(" and "),e("code",[a._v("getCharacter")]),a._v(":")]),a._v(" "),e("div",{staticClass:"language-scala extra-class"},[e("pre",{pre:!0,attrs:{class:"language-scala"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("case")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" Character"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("name"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("String")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("def")]),a._v(" getCharacters"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" List"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("Character"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("def")]),a._v(" getCharacter"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("name"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("String")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" Option"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("Character"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("?")]),a._v("\n")])])]),e("p",[a._v("Let's create a case class named "),e("code",[a._v("Queries")]),a._v(" that will represent our API, with 2 fields named and modeled after the functions we want to expose (a "),e("em",[a._v("record of functions")]),a._v("). We then create a value of this class that calls our actual functions. This is our resolver.")]),a._v(" "),e("div",{staticClass:"language-scala extra-class"},[e("pre",{pre:!0,attrs:{class:"language-scala"}},[e("code",[e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// schema")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("case")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" CharacterName"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("name"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token builtin"}},[a._v("String")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("case")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("class")]),a._v(" Queries"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("characters"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" List"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("Character"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v("\n                   character"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v(":")]),a._v(" CharacterName "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("=>")]),a._v(" Option"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("Character"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token comment"}},[a._v("// resolver")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("val")]),a._v(" queries "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" Queries"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("getCharacters"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(",")]),a._v(" args "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("=>")]),a._v(" getCharacter"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("args"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("name"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),e("p",[a._v("The next step is creating our graphql interpreter. First, we wrap our query resolver inside a "),e("code",[a._v("RootResolver")]),a._v(", the root object that contains queries, mutations and subscriptions. Only queries are mandatory. Then we can call the "),e("code",[a._v("graphQL")]),a._v(" function which will turn our simple resolver value into an interpreter. The whole schema will be derived at compile time, meaning that if it compiles, it will be able to serve it.")]),a._v(" "),e("div",{staticClass:"language-scala extra-class"},[e("pre",{pre:!0,attrs:{class:"language-scala"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" caliban"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("GraphQL"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("graphQL\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("import")]),a._v(" caliban"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("RootResolver\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("val")]),a._v(" interpreter "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" graphQL"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("RootResolver"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("queries"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),e("p",[a._v("You can use "),e("code",[a._v("interpreter.render")]),a._v(" to visualize the schema generated, in this case:")]),a._v(" "),e("div",{staticClass:"language-graphql extra-class"},[e("pre",{pre:!0,attrs:{class:"language-graphql"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("type")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Character")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("name")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" String"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("type")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token class-name"}},[a._v("Queries")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  "),e("span",{pre:!0,attrs:{class:"token attr-name"}},[a._v("characters")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(":")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("[")]),a._v("Character"),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("]")]),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("!")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v("\n")])])]),e("p",[a._v("Now you can call "),e("code",[a._v("interpreter.execute")]),a._v(" with a given GraphQL query, and you will get an "),e("code",[a._v("ZIO[R, CalibanError, ResponseValue]")]),a._v(" as a response. Use "),e("code",[a._v("ResponseValue#toString")]),a._v(" to get the JSON representation of the result.")]),a._v(" "),e("div",{staticClass:"language-scala extra-class"},[e("pre",{pre:!0,attrs:{class:"language-scala"}},[e("code",[e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("val")]),a._v(" query "),e("span",{pre:!0,attrs:{class:"token operator"}},[a._v("=")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token string"}},[a._v('"""\n  { \n    characters {\n      name\n    }\n  }"""')]),a._v("\n\n"),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("for")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("{")]),a._v("\n  result "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("<-")]),a._v(" interpreter"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("execute"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("query"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n  _      "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("<-")]),a._v(" zio"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("console"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("putStrLn"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),a._v("result"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(".")]),a._v("toString"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n"),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("}")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token keyword"}},[a._v("yield")]),a._v(" "),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v("(")]),e("span",{pre:!0,attrs:{class:"token punctuation"}},[a._v(")")]),a._v("\n")])])]),e("p",[a._v("The "),e("code",[a._v("CalibanError")]),a._v(" can be:")]),a._v(" "),e("ul",[e("li",[a._v("a "),e("code",[a._v("ParsingError")]),a._v(": the query has invalid syntax")]),a._v(" "),e("li",[a._v("a "),e("code",[a._v("ValidationError")]),a._v(": the query was parsed but does not match the schema")]),a._v(" "),e("li",[a._v("an "),e("code",[a._v("ExecutionError")]),a._v(": an error happened while executing the query")])]),a._v(" "),e("p",[a._v("Caliban itself is not tied to any web framework, you are free to expose this function using the protocol and library of your choice. The "),e("a",{attrs:{href:"https://github.com/ghostdogpr/caliban/tree/master/http4s",target:"_blank",rel:"noopener noreferrer"}},[a._v("caliban-http4s"),e("OutboundLink")],1),a._v(" module provides an "),e("code",[a._v("Http4sAdapter")]),a._v(" that exposes an interpreter over HTTP and WebSocket using http4s.")])])}),[],!1,null,null,null);t.default=r.exports}}]);