(window.webpackJsonp=window.webpackJsonp||[]).push([[10],{330:function(e,a,t){"use strict";t.r(a);var r=t(33),n=Object(r.a)({},(function(){var e=this,a=e.$createElement,t=e._self._c||a;return t("ContentSlotsDistributor",{attrs:{"slot-key":e.$parent.slotKey}},[t("h1",{attrs:{id:"federation"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#federation"}},[e._v("#")]),e._v(" Federation")]),e._v(" "),t("p",[t("strong",[e._v("Federation")]),e._v(" is an optional module which can be included in your configuration to enroll with a federated schema.")]),e._v(" "),t("h2",{attrs:{id:"dependencies"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#dependencies"}},[e._v("#")]),e._v(" Dependencies")]),e._v(" "),t("p",[t("code",[e._v("caliban-federation")]),e._v(" only depends on "),t("code",[e._v("caliban-core")]),e._v(" and is very unobtrusive.")]),e._v(" "),t("p",[e._v("To use, add the following line to your "),t("code",[e._v("build.sbt")]),e._v(" file:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('libraryDependencies += "com.github.ghostdogpr" %% "caliban-federation" % "0.7.5"\n')])])]),t("h2",{attrs:{id:"federating"}},[t("a",{staticClass:"header-anchor",attrs:{href:"#federating"}},[e._v("#")]),e._v(" Federating")]),e._v(" "),t("p",[e._v("Federation allows graphs to become part of a larger graph without having to share models or create brittle\nschema stitching code at the gateway level.")]),e._v(" "),t("p",[e._v("You can read more about federation and why it may be useful "),t("a",{attrs:{href:"https://www.apollographql.com/docs/apollo-server/federation/introduction/",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),t("OutboundLink")],1),e._v(".")]),e._v(" "),t("p",[e._v("Federation creates a wrapper over your existing schema so that it can add the necessary hooks to support\ninteraction with the gateway.")]),e._v(" "),t("p",[e._v("If you already have a graph you can add federation simply by calling the wrapper function "),t("code",[e._v("federate")])]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('import caliban.federation._\n\nval schema: GraphQL[R] = graphQL(RootResolver(Queries(\n  characters = List(Character("Amos"))\n)))\n\nval federatedSchema: GraphQL[R] = federate(schema)\n')])])]),t("p",[e._v("This will wrap the bare minimum schema additions around your API so that the gateway will recognize your schema.\nTo actually enable entity resolution you will need to do a bit of leg work.")]),e._v(" "),t("p",[e._v('First, any types that will be "resolvable" need to be annotated with a '),t("code",[e._v("@key")]),e._v(" directive. You can use a helper function found\nin the "),t("code",[e._v("federation")]),e._v(" package to help with that.")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('@GQLDirective(Key("name"))\ncase class Character(name: String)\n')])])]),t("p",[e._v("The "),t("code",[e._v('"name"')]),e._v(" field is a field selector minus the outer braces.")]),e._v(" "),t("p",[e._v("If you need to extend a type from another service, you will need to define a stub version of it in the current service\nand annotate it with the "),t("code",[e._v("@extends")]),e._v(" annotation")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v('@GQLDirective(Key("season episode")) \n@GQLDirective(Extend)\ncase class Episode(@GQLDirective(External) season: Int, @GQLDirective(External) episode: Int, cast: List[Character])\n')])])]),t("p",[e._v("Note the additional annotations we needed in this case. "),t("code",[e._v("Extend")]),e._v(" is needed to tell the gateway that this type is defined within\nanother service, while the "),t("code",[e._v("External")]),e._v(" flags these fields as being owned by the other service (there are several other annotations\navailable that you are encouraged to read about).")]),e._v(" "),t("p",[e._v("Once you have annotated your types you need to tell "),t("code",[e._v("Federation")]),e._v(" how to resolve those types. Federation uses a slightly\ndifferent mechanism in resolving types from a standard GraphQL query, so for each type that you wish to support, you will\nneed to add an "),t("code",[e._v("EntityResolver")]),e._v(":")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("EntityResolver[CharacterService, CharacterArgs, Character](args => \n  ZQuery.fromEffect(characters.getCharacter(args.name))\n)  \n")])])]),t("p",[e._v("In the above we need to define an resolver which takes an "),t("code",[e._v("R")]),e._v(" environment type,\nan "),t("code",[e._v("A")]),e._v(" which has an implicit "),t("code",[e._v("ArgBuilder")]),e._v(" and an "),t("code",[e._v("Option[Out]")]),e._v(" where "),t("code",[e._v("Out")]),e._v(" has an implicit\n"),t("code",[e._v("Schema[R, Out]")]),e._v(" available. Creating the above we can now add these resolvers to our federated schema like so:")]),e._v(" "),t("div",{staticClass:"language- extra-class"},[t("pre",{pre:!0,attrs:{class:"language-text"}},[t("code",[e._v("federate(schema, aResolver, additionalResolvers:_*)\n")])])]),t("p",[e._v("You can now use the resulting "),t("code",[e._v("GraphQL[R]")]),e._v(" to start querying. You can also see the full code example "),t("a",{attrs:{href:"https://github.com/ghostdogpr/caliban/tree/master/examples/src/main/scala/caliban/federation",target:"_blank",rel:"noopener noreferrer"}},[e._v("here"),t("OutboundLink")],1)])])}),[],!1,null,null,null);a.default=n.exports}}]);